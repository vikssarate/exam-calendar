<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Current Due Task — Synced (Conflict-safe)</title>
<link rel="icon" href="data:,">
<style>
  :root{
    --bg:#0f1220; --card:#161b2b; --ink:#eef1ff; --muted:#9aa3c7; --line:#2a3052;
    --accent:#6ca8ff; --ok:#7bd88f; --warn:#ffd166; --bad:#ff7575;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
  .wrap{max-width:1100px;margin:24px auto;padding:0 14px}
  header{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;margin-bottom:10px}
  h1{font-size:18px;margin:0}
  .panel{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button{background:var(--accent);color:#06102a;border:0;border-radius:10px;padding:8px 12px;font-weight:700;cursor:pointer}
  button.secondary{background:#202a44;color:var(--ink);border:1px solid var(--line)}
  button.small{padding:4px 8px;border-radius:8px;font-size:12px}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--line);background:#0b1128;color:#9aa3c7;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .kpi{display:flex;align-items:center;gap:10px;padding:10px;border:1px solid var(--line);border-radius:10px;background:#0b1128}
  .kpi .n{font-weight:800;font-size:18px}
  .kpi .label{color:#9aa3c7;font-size:12px}
  .foot{display:flex;justify-content:flex-end;margin-top:6px;color:#9aa3c7;font-size:12px}

  input[type="text"]{width:100%;background:#0b1128;border:1px solid var(--line);color:#eef1ff;
    padding:8px 10px;border-radius:8px;outline:none}
  input[type="text"]::placeholder{color:#6b7280}

  /* Subject & topic layout */
  .subject-card{border:1px solid var(--line);border-radius:12px;background:#101731;padding:10px;margin:10px 0}
  .subject-head{display:flex;gap:10px;align-items:center}
  .subject-head .left{flex:1 1 auto;display:flex;gap:10px;align-items:center}
  .subject-actions{display:flex;gap:8px;align-items:center}
  .subject-actions .ck{display:inline-flex;gap:6px;align-items:center;color:#9aa3c7;font-size:12px}
  .subject-actions .del{background:#23121a;color:#ffd6da;border:1px solid #4b1a23}

  .topic-row{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center;margin:8px 0 0}
  .topic-controls{display:flex;gap:14px;align-items:center}
  .ck{display:inline-flex;gap:6px;align-items:center;color:#9aa3c7;font-size:12px;user-select:none}
  .ck input{transform:scale(1.15)}
  .topic-del{background:#23121a;color:#ffd6da;border:1px solid #4b1a23}
  .add-topic{margin-top:10px}

  /* Sync bar */
  .syncbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:8px 0}
  .dot{width:8px;height:8px;border-radius:50%}
  .on{background:#7bd88f}.off{background:#ff7575}.warn{background:#ffd166}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Current Due Task</h1>
    <div class="controls">
      <span class="badge" id="todayLabel"></span>
      <span class="badge" id="activeTopicsBadge">Active Topics: 0</span>
      <button id="addSubject">+ Add Subject</button>
      <button id="resetToday" class="secondary">Reset Today</button>
    </div>
  </header>

  <section class="panel">
    <div class="syncbar">
      <span class="badge">DB: couch.techstudy.me / progress</span>
      <span class="dot off" id="liveDot" title="Live sync status"></span>
      <span class="badge" id="syncLabel">Sync: initializing…</span>
      <button class="small" id="syncNow">Sync now</button>
      <button class="small" id="pullNow">Pull now</button>
      <button class="small" id="toggleLive">Pause live</button>
    </div>
  </section>

  <section class="panel" id="subjectsPanel">
    <!-- subject cards render here -->
    <div class="foot"><b>Rules:</b> Topic <b>Chunk</b> resets daily only when Topic isn’t done. Topic/Subject done persist.</div>
  </section>

  <h2 style="font-size:16px;margin:18px 0 8px">Today Progress Report</h2>
  <section class="panel">
    <div class="grid">
      <div class="kpi">
        <div class="n" id="chunksDoneN">0</div>
        <div><div class="label">Chunks completed today</div><div class="label">Total today: <span id="chunksTotalN">0</span></div></div>
      </div>
      <div class="kpi">
        <div class="n" id="topicsDoneN">0</div>
        <div><div class="label">Topics done today</div><div class="label">Total active: <span id="topicsActiveN">0</span></div></div>
      </div>
      <div class="kpi">
        <div class="n" id="subjectsDoneN">0</div>
        <div><div class="label">Subjects done today</div><div class="label">Total active: <span id="subjectsActiveN">0</span></div></div>
      </div>
    </div>
  </section>
</div>

<!-- PouchDB -->
<script src="https://cdn.jsdelivr.net/npm/pouchdb@8.0.1/dist/pouchdb.min.js"></script>
<script>
(() => {
  // ---------- IDs / URLs ----------
  const SUBJECTS_ID = "subjects_v3";                 // single doc for structure
  const REMOTE_URL  = "https://couch.techstudy.me/progress";
  const todayId = () => `status-${dateKey()}`;       // per-day status doc

  // ---------- DBs ----------
  const local  = new PouchDB("progress_local_v3");
  const remote = new PouchDB(REMOTE_URL, {skip_setup:false});

  // in-memory mirrors
  let subjectsDoc = null;   // {_id,_rev,version,nextSID,nextTID,subjects:[{id,name,subjectDone,topics:[{tid,name,done}]}]}
  let statusDoc   = null;   // {_id,_rev,version,map:{ 't:<tid>':{chunk,topicToday}, 's:<sid>':{subjectToday} } }
  let liveSync = null;
  let isTyping = false, pendingRender = false;

  // ---------- utils ----------
  function dateKey(d=new Date()){
    const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), dd=String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${dd}`;
  }
  const debounce = (fn,ms=200)=>{let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),ms);}};

  // Conflict-safe updater
  async function safeUpdate(id, mutator){
    for(let i=0;i<4;i++){
      try{
        let cur;
        try{ cur = await local.get(id); }catch(e){ if(e.status===404) cur = {_id:id}; else throw e; }
        const next = JSON.parse(JSON.stringify(cur));
        const updated = mutator(next) || next;
        const res = await local.put(updated);
        return res;
      }catch(e){
        if(e.status === 409) continue; // retry with newer rev
        throw e;
      }
    }
    throw new Error("conflict loop");
  }

  // ---------- bootstrap ----------
  async function firstPull(){
    try{ await PouchDB.replicate(remote, local, {batch_size:200}); }catch(e){ /* offline ok */ }
  }
  async function ensureSubjects(){
    try{ subjectsDoc = await local.get(SUBJECTS_ID); }
    catch(e){
      if(e.status===404){
        subjectsDoc = {_id:SUBJECTS_ID, version:3, nextSID:1, nextTID:1, subjects:[]};
        const res = await local.put(subjectsDoc); subjectsDoc._rev = res.rev;
      } else throw e;
    }
  }
  async function ensureStatus(){
    const id = todayId();
    try{ statusDoc = await local.get(id); }
    catch(e){
      if(e.status===404){
        statusDoc = {_id:id, version:1, map:{}};
        const res = await local.put(statusDoc); statusDoc._rev = res.rev;
      } else throw e;
    }
  }

  // ---------- live sync ----------
  function setLiveIndicator(state, msg){
    const dot = document.getElementById("liveDot");
    const label = document.getElementById("syncLabel");
    dot.className = `dot ${state}`;
    label.textContent = msg || (state==="on"?"Sync: live":"Sync: offline");
  }
  function startLive(){
    if(liveSync) return;
    liveSync = local.sync(remote, {live:true, retry:true})
      .on("change", ()=> setLiveIndicator("on","Sync: live (changed)"))
      .on("paused", err => setLiveIndicator(err?"warn":"on", err?"Sync: paused (retrying)":"Sync: live"))
      .on("active", ()=> setLiveIndicator("on","Sync: live (active)"))
      .on("error", ()=> setLiveIndicator("off","Sync: offline"));
  }
  function stopLive(){ if(liveSync){ liveSync.cancel(); liveSync=null; setLiveIndicator("off","Sync: paused"); } }

  // local change feed → refresh mirrors (but avoid re-rendering while typing)
  local.changes({since:"now", live:true, include_docs:true}).on("change", ch=>{
    if(ch.id===SUBJECTS_ID){ subjectsDoc = ch.doc; }
    else if(ch.id===todayId()){ statusDoc = ch.doc; }
    if(isTyping){ pendingRender = true; return; }
    render();
  });

  // ---------- UI refs ----------
  const $panel = document.getElementById("subjectsPanel");
  const $addSubject = document.getElementById("addSubject");
  const $resetToday = document.getElementById("resetToday");
  const $todayLabel = document.getElementById("todayLabel");
  const $activeTopicsBadge = document.getElementById("activeTopicsBadge");

  const $chunksDoneN = document.getElementById("chunksDoneN");
  const $chunksTotalN = document.getElementById("chunksTotalN");
  const $topicsDoneN = document.getElementById("topicsDoneN");
  const $topicsActiveN = document.getElementById("topicsActiveN");
  const $subjectsDoneN = document.getElementById("subjectsDoneN");
  const $subjectsActiveN = document.getElementById("subjectsActiveN");

  // ---------- render ----------
  function render(){
    if(!subjectsDoc || !statusDoc) return;
    const subs = subjectsDoc.subjects || [];
    const st = statusDoc.map || {};
    const dk = dateKey();
    $todayLabel.textContent = `Today: ${dk}`;
    // clear existing cards
    [...$panel.querySelectorAll(".subject-card")].forEach(el=>el.remove());

    subs.forEach((s, idx)=>{
      const card = document.createElement("div");
      card.className = "subject-card";

      // head
      const head = document.createElement("div");
      head.className = "subject-head";
      head.innerHTML = `
        <div class="left">
          <div class="badge">${idx+1}</div>
          <input type="text" placeholder="Subject…" value="${s.name||""}" autocapitalize="sentences" spellcheck="false">
        </div>
        <div class="subject-actions">
          <label class="ck"><input type="checkbox" ${s.subjectDone?"checked":""}> <span>Subject</span></label>
          <button class="small del">Delete</button>
        </div>`;
      const subjInput = head.querySelector('input[type="text"]');
      const subjDoneEl = head.querySelector('input[type="checkbox"]');
      const subjDel = head.querySelector('.del');

      subjInput.addEventListener("focus", ()=>{ isTyping=true; });
      subjInput.addEventListener("blur",  ()=>{ isTyping=false; if(pendingRender){ pendingRender=false; render(); }});
      subjInput.addEventListener("input", debounce(async e=>{
        const val = e.target.value;
        await safeUpdate(SUBJECTS_ID, doc => {
          doc.version ??= 3; doc.nextSID ??= 1; doc.nextTID ??= 1; doc.subjects ??= [];
          const target = doc.subjects.find(x=>x.id===s.id);
          if(target) target.name = val;
          return doc;
        });
      }));

      subjDoneEl.addEventListener("change", async e=>{
        const checked = e.target.checked;
        await safeUpdate(SUBJECTS_ID, doc => {
          (doc.subjects||[]).find(x=>x.id===s.id).subjectDone = checked; return doc;
        });
        await safeUpdate(todayId(), doc => {
          doc.version ??= 1; doc.map ??= {};
          const key = `s:${s.id}`;
          doc.map[key] = doc.map[key] || {subjectToday:false};
          doc.map[key].subjectToday = checked;
          return doc;
        });
      });

      subjDel.addEventListener("click", async ()=>{
        await safeUpdate(SUBJECTS_ID, doc => {
          doc.subjects = (doc.subjects||[]).filter(x=>x.id!==s.id);
          return doc;
        });
      });

      card.appendChild(head);

      // topics
      (s.topics||[]).forEach(tp=>{
        const key = `t:${tp.tid}`;
        const per = st[key] || {};
        const chunkChecked = tp.done ? true : !!per.chunk;
        const topicChecked = !!tp.done;

        const row = document.createElement("div");
        row.className = "topic-row";
        row.innerHTML = `
          <input type="text" placeholder="Topic…" value="${tp.name||""}" autocapitalize="sentences" spellcheck="false">
          <div class="topic-controls">
            <label class="ck"><input type="checkbox" ${chunkChecked?"checked":""} ${tp.done?"disabled":""}><span>Chunk</span></label>
            <label class="ck"><input type="checkbox" ${topicChecked?"checked":""}><span>Topic</span></label>
            <button class="small topic-del">Delete</button>
          </div>`;

        const [tInput] = row.getElementsByTagName("input");
        const [chunkEl, topicEl] = row.querySelectorAll('.topic-controls input');
        const tDel = row.querySelector(".topic-del");

        tInput.addEventListener("focus", ()=>{ isTyping=true; });
        tInput.addEventListener("blur",  ()=>{ isTyping=false; if(pendingRender){ pendingRender=false; render(); }});
        tInput.addEventListener("input", debounce(async e=>{
          const val = e.target.value;
          await safeUpdate(SUBJECTS_ID, doc => {
            const subj = (doc.subjects||[]).find(x=>x.id===s.id);
            if(subj){ const topic = (subj.topics||[]).find(z=>z.tid===tp.tid); if(topic) topic.name = val; }
            return doc;
          });
        }));

        chunkEl.addEventListener("change", async e=>{
          const checked = e.target.checked;
          await safeUpdate(todayId(), doc => {
            doc.version ??= 1; doc.map ??= {};
            doc.map[key] = doc.map[key] || {chunk:false,topicToday:false};
            doc.map[key].chunk = checked;
            return doc;
          });
        });

        topicEl.addEventListener("change", async e=>{
          const checked = e.target.checked;
          await safeUpdate(SUBJECTS_ID, doc => {
            const subj = (doc.subjects||[]).find(x=>x.id===s.id);
            if(subj){ const topic = (subj.topics||[]).find(z=>z.tid===tp.tid); if(topic) topic.done = checked; }
            return doc;
          });
          await safeUpdate(todayId(), doc => {
            doc.version ??= 1; doc.map ??= {};
            doc.map[key] = doc.map[key] || {chunk:false,topicToday:false};
            doc.map[key].topicToday = checked;
            if(checked) doc.map[key].chunk = true;
            return doc;
          });
        });

        tDel.addEventListener("click", async ()=>{
          await safeUpdate(SUBJECTS_ID, doc => {
            const subj = (doc.subjects||[]).find(x=>x.id===s.id);
            if(subj){ subj.topics = (subj.topics||[]).filter(z=>z.tid!==tp.tid); }
            return doc;
          });
        });

        card.appendChild(row);
      });

      // add topic
      const addT = document.createElement("button");
      addT.className = "small add-topic";
      addT.textContent = "+ Add Topic";
      addT.addEventListener("click", async ()=>{
        await safeUpdate(SUBJECTS_ID, doc => {
          doc.version ??= 3; doc.nextTID ??= 1; doc.subjects ??= [];
          const subj = (doc.subjects||[]).find(x=>x.id===s.id);
          if(subj){
            subj.topics = subj.topics || [];
            subj.topics.push({ tid: doc.nextTID++, name:"", done:false, created: Date.now() });
          }
          return doc;
        });
      });
      card.appendChild(addT);

      $panel.appendChild(card);
    });

    updateKPIs();
  }

  function updateKPIs(){
    if(!subjectsDoc || !statusDoc) return;
    const subs = subjectsDoc.subjects || [];
    const map  = statusDoc.map || {};
    let chunksToday=0, topicsToday=0, subjectsToday=0;

    subs.forEach(s=>{
      if(map[`s:${s.id}`]?.subjectToday) subjectsToday++;
      (s.topics||[]).forEach(tp=>{
        const key = `t:${tp.tid}`;
        if(map[key]?.chunk)      chunksToday++;
        if(map[key]?.topicToday) topicsToday++;
      });
    });

    const activeTopics   = subs.reduce((a,s)=>a + (s.topics||[]).filter(t=>!t.done).length, 0);
    const activeSubjects = subs.filter(s=>!s.subjectDone).length;

    $chunksDoneN.textContent = chunksToday;
    $chunksTotalN.textContent = activeTopics;
    $topicsDoneN.textContent = topicsToday;
    $topicsActiveN.textContent = activeTopics;
    $subjectsDoneN.textContent = subjectsToday;
    $subjectsActiveN.textContent = activeSubjects;
    $activeTopicsBadge.textContent = `Active Topics: ${activeTopics}`;
  }

  // ---------- actions ----------
  document.getElementById("addSubject").addEventListener("click", async ()=>{
    await safeUpdate(SUBJECTS_ID, doc => {
      doc.version ??= 3; doc.nextSID ??= 1; doc.subjects ??= [];
      doc.subjects.push({ id: doc.nextSID++, name:"", subjectDone:false, topics:[], created: Date.now() });
      return doc;
    });
  });

  function clearToday(){
    safeUpdate(todayId(), doc => { doc.version ??= 1; doc.map = {}; return doc; });
  }
  document.getElementById("resetToday").addEventListener("click", ()=> {
    if(confirm("Reset today's ticks? (Topic/Subject Done stay)")) clearToday();
  });

  // date rollover
  function ensureToday(){
    const id = todayId();
    if(!statusDoc || statusDoc._id !== id) ensureStatus().then(render);
  }
  setInterval(ensureToday, 60*1000);

  // sync controls
  document.getElementById("syncNow").addEventListener("click", async ()=>{
    document.getElementById("syncLabel").textContent = "Sync: pushing…";
    try{ await local.replicate.to(remote); document.getElementById("syncLabel").textContent = "Sync: pushed"; }
    catch{ document.getElementById("syncLabel").textContent = "Sync: push failed"; }
  });
  document.getElementById("pullNow").addEventListener("click", async ()=>{
    document.getElementById("syncLabel").textContent = "Sync: pulling…";
    try{ await local.replicate.from(remote); document.getElementById("syncLabel").textContent = "Sync: pulled"; }
    catch{ document.getElementById("syncLabel").textContent = "Sync: pull failed"; }
  });
  document.getElementById("toggleLive").addEventListener("click", e=>{
    if(liveSync){ stopLive(); e.target.textContent = "Resume live"; }
    else{ startLive(); e.target.textContent = "Pause live"; }
  });

  // ---------- init ----------
  (async function init(){
    try{
      await firstPull();          // auto-pull for new device / cleared storage
      await ensureSubjects();
      await ensureStatus();
      render();
      startLive();
    }catch(e){
      console.error(e);
      setLiveIndicator("warn","Sync: init failed (offline?)");
      await ensureSubjects();
      await ensureStatus();
      render();
    }
  })();
})();
</script>
</body>
</html>
